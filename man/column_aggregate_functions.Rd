% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R, R/hidden_functions.R, R/functions.R
\name{approxCountDistinct}
\alias{approxCountDistinct}
\alias{.n_distinct}
\alias{n_distinct}
\alias{n_distinct,Column-method}
\alias{column_aggregate_functions}
\alias{approxCountDistinct,Column-method}
\alias{kurtosis,Column-method}
\alias{kurtosis}
\alias{max.Column}
\alias{max}
\alias{max,Column-method}
\alias{mean.Column}
\alias{mean}
\alias{mean,Column-method}
\alias{min.Column}
\alias{min}
\alias{min,Column-method}
\alias{skewness,Column-method}
\alias{skewness}
\alias{stddev,Column-method}
\alias{stddev}
\alias{stddev_pop,Column-method}
\alias{stddev_pop}
\alias{stddev_samp,Column-method}
\alias{stddev_samp}
\alias{sum,Column-method}
\alias{sum}
\alias{sumDistinct,Column-method}
\alias{sumDistinct}
\alias{variance,Column-method}
\alias{variance}
\alias{var_pop,Column-method}
\alias{var_pop}
\alias{var_samp,Column-method}
\alias{var_samp}
\alias{countDistinct,Column-method}
\alias{countDistinct}
\alias{collect_list,Column-method}
\alias{collect_list}
\alias{collect_set,Column-method}
\alias{collect_set}
\alias{grouping_bit,Column-method}
\alias{grouping_bit}
\alias{grouping_id,Column-method}
\alias{grouping_id}
\title{Aggregate functions for Column operations}
\usage{
approxCountDistinct(x, rsd, ...)

collect_list(x)

collect_set(x)

countDistinct(x, ...)

grouping_bit(x)

grouping_id(x, ...)

kurtosis(x)

n_distinct(x, ...)

skewness(x)

stddev(x)

stddev_pop(x)

stddev_samp(x)

sumDistinct(x)

variance(x)

var_pop(x)

var_samp(x)

.n_distinct(...)

\S4method{approxCountDistinct}{Column}(x, rsd = 0.05)

\S4method{kurtosis}{Column}(x)

\method{max}{Column}(x, na.rm = FALSE, ...)

\method{mean}{Column}(x, ...)

\method{min}{Column}(x, na.rm = FALSE, ...)

\S4method{skewness}{Column}(x)

\S4method{stddev}{Column}(x)

\S4method{stddev_pop}{Column}(x)

\S4method{stddev_samp}{Column}(x)

\S4method{sum}{Column}(x)

\S4method{sumDistinct}{Column}(x)

\S4method{variance}{Column}(x)

\S4method{var_pop}{Column}(x)

\S4method{var_samp}{Column}(x)

\S4method{countDistinct}{Column}(x, ...)

\S4method{collect_list}{Column}(x)

\S4method{collect_set}{Column}(x)

\S4method{grouping_bit}{Column}(x)

\S4method{grouping_id}{Column}(x, ...)
}
\arguments{
\item{x}{Column to compute on.}

\item{rsd}{maximum estimation error allowed (default = 0.05).}

\item{...}{additional argument(s). For example, it could be used to pass
additional Columns.}
}
\description{
Aggregate functions defined for \code{Column}.
}
\details{
\code{n_distinct}: Returns the number of distinct items in a group.

\code{approxCountDistinct}: Returns the approximate number of distinct items
in a group.

\code{kurtosis}: Returns the kurtosis of the values in a group.

\code{max}: Returns the maximum value of the expression in a group.

\code{mean}: Returns the average of the values in a group. Alias for \code{avg}.

\code{min}: Returns the minimum value of the expression in a group.

\code{skewness}: Returns the skewness of the values in a group.

\code{stddev}: Alias for \code{std_dev}.

\code{stddev_pop}: Returns the population standard deviation of the
                   expression in a group.

\code{stddev_samp}: Returns the unbiased sample standard deviation of the
                    expression in a group.

\code{sum}: Returns the sum of all values in the expression.

\code{sumDistinct}: Returns the sum of distinct values in the expression.

\code{var_pop}: Returns the population variance of the values in a group.

\code{var_samp}: Returns the unbiased variance of the values in a group.

\code{countDistinct}: Returns the number of distinct items in a group.

\code{collect_list}: Creates a list of objects with duplicates.
Note: the function is non-deterministic because the order of collected results depends
on order of rows which may be non-deterministic after a shuffle.

\code{collect_set}: Creates a list of objects with duplicate elements eliminated.
Note: the function is non-deterministic because the order of collected results depends
on order of rows which may be non-deterministic after a shuffle.

\code{grouping_bit}: Indicates whether a specified column in a GROUP BY list is aggregated or
not, returns 1 for aggregated or 0 for not aggregated in the result set. Same as \code{GROUPING}
in SQL and \code{grouping} function in Scala.

\code{grouping_id}: Returns the level of grouping.
Equals to \code{
grouping_bit(c1) * 2^(n - 1) + grouping_bit(c2) * 2^(n - 2)  + ... + grouping_bit(cn)
}.
}
\note{
n_distinct since 1.4.0

approxCountDistinct(Column) since 1.4.0

kurtosis since 1.6.0

max since 1.5.0

mean since 1.5.0

min since 1.5.0

skewness since 1.6.0

stddev since 1.6.0

stddev_pop since 1.6.0

stddev_samp since 1.6.0

sum since 1.5.0

sumDistinct since 1.4.0

variance since 1.6.0

var_pop since 1.5.0

var_samp since 1.6.0

countDistinct since 1.4.0

collect_list since 2.3.0

collect_set since 2.3.0

grouping_bit since 2.3.0

grouping_id since 2.3.0
}
\examples{
\dontrun{
# Dataframe used throughout this doc
df <- spark_tbl(cbind(model = rownames(mtcars),
                      mtcars))
}

\dontrun{
head(select(df, approxCountDistinct(df$gear)))
head(select(df, approxCountDistinct(df$gear, 0.02)))
head(select(df, countDistinct(df$gear, df$cyl)))
head(select(df, n_distinct(df$gear)))
head(distinct(select(df, "gear")))}

\dontrun{
head(select(df, mean(df$mpg), sd(df$mpg), skewness(df$mpg), kurtosis(df$mpg)))}

\dontrun{
head(select(df, avg(df$mpg), mean(df$mpg), sum(df$mpg), min(df$wt), max(df$qsec)))

# metrics by num of cylinders
tmp <- agg(groupBy(df, "cyl"), avg(df$mpg), avg(df$hp), avg(df$wt), avg(df$qsec))
head(orderBy(tmp, "cyl"))

# car with the max mpg
mpg_max <- as.numeric(collect(agg(df, max(df$mpg))))
head(where(df, df$mpg == mpg_max))}

\dontrun{
head(select(df, sumDistinct(df$gear)))
head(distinct(select(df, "gear")))}

\dontrun{
df2 = df[df$mpg > 20, ]
collect(select(df2, collect_list(df2$gear)))
collect(select(df2, collect_set(df2$gear)))}

\dontrun{
# With cube
agg(
  cube(df, "cyl", "gear", "am"),
  mean(df$mpg),
  grouping_bit(df$cyl), grouping_bit(df$gear), grouping_bit(df$am)
)

# With rollup
agg(
  rollup(df, "cyl", "gear", "am"),
  mean(df$mpg),
  grouping_bit(df$cyl), grouping_bit(df$gear), grouping_bit(df$am)
)}

\dontrun{
# With cube
agg(
  cube(df, "cyl", "gear", "am"),
  mean(df$mpg),
  grouping_id(df$cyl, df$gear, df$am)
)

# With rollup
agg(
  rollup(df, "cyl", "gear", "am"),
  mean(df$mpg),
  grouping_id(df$cyl, df$gear, df$am)
)}
}
\seealso{
Other aggregate functions: 
\code{\link{avg}()},
\code{\link{corr}()},
\code{\link{firstItem}()},
\code{\link{lastItem}()}
}
\concept{aggregate functions}
