% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rank.R
\name{column_window_functions}
\alias{column_window_functions}
\alias{.rank}
\alias{rank}
\alias{.min_rank}
\alias{.dense_rank}
\alias{dense_rank}
\alias{.percent_rank}
\alias{percent_rank}
\alias{.cume_dist}
\alias{cume_dist}
\alias{.row_number}
\alias{row_number}
\alias{.ntile}
\alias{ntile}
\title{Window functions for Column operations}
\usage{
.rank(x, ...)

.min_rank(x, ...)

.dense_rank(x, ...)

.percent_rank(x, ...)

.cume_dist(x, ...)

.row_number(...)

.ntile(x, n, ...)
}
\arguments{
\item{x}{the \code{Column} or \code{WindowSpec} to use for rank functions.
This will default to ordering by
\code{monotonically_increasing_id()}. If using \code{WindowSpec}
you can also add partitioning columns, though any grouping vars
will be respected here.}

\item{...}{additional argument(s).}

\item{n}{an integer of the number of tiles used in \code{ntile}}
}
\description{
Window functions defined for \code{Column}.
}
\details{
\code{rank}: Returns the rank of rows within a window partition.
The difference between rank and dense_rank is that dense_rank leaves no gaps in ranking
sequence when there are ties. That is, if you were ranking a competition using dense_rank
and had three people tie for second place, you would say that all three were in second
place and that the next person came in third. Rank would give me sequential numbers, making
the person that came in third place (after the ties) would register as coming in fifth.
This is equivalent to the \code{RANK} function in SQL.
This can be used with either a \code{Column} or a \code{WindowSpec}.

\code{min_rank}: An alias for \code{rank}. In Spark \code{rank} and
functions as \code{min_rank}. This can be used with either a \code{Column}
or a \code{WindowSpec}.

\code{dense_rank}: Returns the rank of rows within a window partition,
without any gaps. The difference between rank and dense_rank is that
dense_rank leaves no gaps in ranking sequence when there are ties. That is,
if you were ranking a competition using dense_rank and had three people tie
for second place, you would say that all three were in second place and that
the next person came in third. Rank would give me sequential numbers, making
the person that came in third place (after the ties) would register as
coming in fifth. This is equivalent to the \code{DENSE_RANK} function in
SQL. This can be used with either a \code{Column} or a \code{WindowSpec}.

\code{percent_rank}: Returns the relative rank (i.e. percentile) of rows
within a window partition.
This is computed by: (rank of row in its partition - 1) / (number of rows in
the partition - 1). This is equivalent to the \code{PERCENT_RANK} function
in SQL. This can be used with either a \code{Column} or a \code{WindowSpec}.

\code{cume_dist}: Returns the cumulative distribution of values within a
window partition, i.e. the fraction of rows that are below the current row:
(number of values before and including x) / (total number of rows in the
partition). This is equivalent to the \code{CUME_DIST} function in SQL.
This can be used with either a \code{Column} or a \code{WindowSpec}.

\code{row_number}: Returns a sequential number starting at 1 within a window
partition. This is equivalent to the \code{ROW_NUMBER} function in SQL.
This can be used with either a \code{Column}, \code{WindowSpec}, or without
an argument, which will order by \code{monotonically_increasing_id()}.

\code{ntile}: Returns the ntile group id (from 1 to n inclusive) in an
ordered window partition. For example, if n is 4, the first quarter of the
rows will get value 1, the second quarter will get 2, the third quarter will
get 3, and the last quarter will get 4. This is equivalent to the
\code{NTILE} function in SQL.
}
\note{
rank since 1.6.0

rank since 1.6.0

dense_rank since 1.6.0

percent_rank since 1.6.0

cume_dist since 1.6.0

row_number since 1.6.0

ntile since 1.6.0
}
\examples{
\dontrun{
# with column names
spark_tbl(iris) \%>\%
  mutate(lead = lead(Petal_Width, 1),
         lag = lag(Petal_Width, 2),
         n = row_number(),
         rank = rank(Petal_Width),
         dense_rank = dense_rank(Petal_Width),
         percent_rank = percent_rank(Petal_Width),
         cume_dist = cume_dist(Petal_Width),
         tiles_4 = ntile(Petal_Width, 4)) \%>\%
 collect

# with grouping things are more efficient
spark_tbl(iris) \%>\%
  group_by(Species) \%>\%
  mutate(lead = lead(Petal_Width, 1),
         lag = lag(Petal_Width, 2),
         n = row_number(),
         rank = rank(Petal_Width),
         dense_rank = dense_rank(Petal_Width),
         percent_rank = percent_rank(Petal_Width),
         cume_dist = cume_dist(Petal_Width),
         tiles_4 = ntile(Petal_Width, 4)) \%>\%
  collect

# you can also use a WindowSpec() to acheive the same thing
wndw <- partitionBy(windowOrderBy("Petal_Width"), "Species")
spark_tbl(iris) \%>\%
  mutate(n = row_number(),
         rank = rank(wndw),
         dense_rank = dense_rank(wndw),
         percent_rank = percent_rank(wndw),
         cume_dist = cume_dist(wndw),
         tiles_4 = ntile(wndw, 4)) \%>\%
  collect
}
}
\concept{window functions}
